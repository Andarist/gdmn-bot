%YAML 1.1
--- 
StructureVersion: "1.0"
Properties: 
  RUID: 147029090_1220419898
  Name: "GS.Общие.Функции работы с json"
  Caption: "GS.Общие.Функции работы с json"
  Version: "1.0.0.1"
  Optional: False
  Internal: True
  MD5: 6F012FECA2DBFCCB25A11F0DF4F656FA
Objects: 
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 147048487_785478087
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      NAME: "VbsJson"
      COMMENT: ~
      EVENT: ~
      FUNCTIONTYPE: ~
      GROUPNAME: ~
      INHERITEDRULE: 0
      LANGUAGE: "VBScript"
      LOCALNAME: ~
      MODIFYDATE: ~
      MODULE: "VBCLASSES"
      MODULECODE: "1010001_17 APPLICATION"
      OBJECTNAME: "APPLICATION"
      OWNERNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      USEDEBUGINFO: 0
      EDITIONDATE: 2019-08-22T20:48:24+03:00
      DISPLAYSCRIPT: ~
      ENTEREDPARAMS: ~
      SCRIPT: | 
        option explicit
        Class VbsJson
            'Author: Demon
            'Date: 2012/5/3
            'Website: http://demon.tw
            Private Whitespace, NumberRegex, StringChunk
            Private b, f, r, n, t
        
            Private Sub Class_Initialize
                Whitespace = " " & vbTab & vbCr & vbLf
                ' символы окончания строки
                b = ChrW(8)
                f = vbFormFeed
                r = vbCr
                n = vbLf
                t = vbTab
        
                Set NumberRegex = New RegExp
                ' шаблон числа
                NumberRegex.Pattern = "(-?(?:0|[1-9]\d*))(\.\d+)?([eE][-+]?\d+)?"
                NumberRegex.Global = False
                NumberRegex.MultiLine = True
                NumberRegex.IgnoreCase = True
                ' шаблон строки (слова). Может начинаться с пробелов, заканчивается кавычкой (конец всей строки),
                ' или 16-ным кодом (ведь кириллица будет закодирована)
                ' первые круглые скобки - сама строка, вторые - разделитель, которым она заканчивается
                Set StringChunk = New RegExp
                StringChunk.Pattern = "([\s\S]*?)([""\\\x00-\x1f])"
                StringChunk.Global = False
                StringChunk.MultiLine = True
                StringChunk.IgnoreCase = True
            End Sub
        
            'Return a JSON string representation of a VBScript data structure
            'Supports the following objects and types
            '+-------------------+---------------+
            '| VBScript          | JSON          |
            '+===================+===============+
            '| Dictionary        | object        |
            '+-------------------+---------------+
            '| Array             | array         |
            '+-------------------+---------------+
            '| String            | string        |
            '+-------------------+---------------+
            '| Number            | number        |
            '+-------------------+---------------+
            '| True              | true          |
            '+-------------------+---------------+
            '| False             | false         |
            '+-------------------+---------------+
            '| Null              | null          |
            '+-------------------+---------------+
            Public Function Encode(ByRef obj)
                Dim buf, i, c, g
                Set buf = CreateObject("Scripting.Dictionary")
                Select Case VarType(obj)
                    Case vbNull
                        buf.Add buf.Count, "null"
                    Case vbBoolean
                        If obj Then
                            buf.Add buf.Count, "true"
                        Else
                            buf.Add buf.Count, "false"
                        End If
                    Case vbInteger, vbLong, vbSingle, vbDouble
                        buf.Add buf.Count, obj
                    Case vbString
                        buf.Add buf.Count, """"
                        For i = 1 To Len(obj)
                            c = Mid(obj, i, 1)
                            Select Case c
                                Case """" buf.Add buf.Count, "\"""
                                Case "\"  buf.Add buf.Count, "\\"
                                Case "/"  buf.Add buf.Count, "/"
                                Case b    buf.Add buf.Count, "\b"
                                Case f    buf.Add buf.Count, "\f"
                                Case r    buf.Add buf.Count, "\r"
                                Case n    buf.Add buf.Count, "\n"
                                Case t    buf.Add buf.Count, "\t"
                                Case Else
                                    If AscW(c) >= 0 And AscW(c) <= 31 Then
                                        c = Right("0" & Hex(AscW(c)), 2)
                                        buf.Add buf.Count, "\u00" & c
                                    Else
                                        buf.Add buf.Count, c
                                    End If
                            End Select
                        Next
                        buf.Add buf.Count, """"
                    Case vbArray + vbVariant
                        g = True
                        buf.Add buf.Count, "["
                        For Each i In obj
                            If g Then g = False Else buf.Add buf.Count, ","
                            buf.Add buf.Count, Encode(i)
                        Next
                        buf.Add buf.Count, "]"
                    Case vbObject
                        If TypeName(obj) = "Dictionary" Then
                            g = True
                            buf.Add buf.Count, "{"
                            For Each i In obj
                                If g Then g = False Else buf.Add buf.Count, ","
                                buf.Add buf.Count, """" & i & """" & ":" & Encode(obj(i))
                            Next
                            buf.Add buf.Count, "}"
                        Else
        '                    Err.Raise 8732,,"None dictionary object"
                            Exception.Raise "Exception", "None dictionary object"
                        End If
                    Case Else
                        buf.Add buf.Count, """" & CStr(obj) & """"
                End Select
                Encode = Join(buf.Items, "")
            End Function
        
            'Return the VBScript representation of ``str(``
            'Performs the following translations in decoding
            '+---------------+-------------------+
            '| JSON          | VBScript          |
            '+===============+===================+
            '| object        | Dictionary        |
            '+---------------+-------------------+
            '| array         | Array             |
            '+---------------+-------------------+
            '| string        | String            |
            '+---------------+-------------------+
            '| number        | Double            |
            '+---------------+-------------------+
            '| true          | True              |
            '+---------------+-------------------+
            '| false         | False             |
            '+---------------+-------------------+
            '| null          | Null              |
            '+---------------+-------------------+
            Public Function Decode(ByRef str)
                Dim idx
                idx = SkipWhitespace(str, 1)
        
                If Mid(str, idx, 1) = "{" Then
                    Set Decode = ScanOnce(str, 1)
                Else
                    Decode = ScanOnce(str, 1)
                End If
            End Function
            
            ' определить, что текст является массивом
            Public Function IsArray(ByVal Str)
                Dim idx
                idx = SkipWhitespace(str, 1)
                IsArray = (Mid(str, idx, 1) = "[" )
            End Function
        
            ' рекурсия для разбора
            Private Function ScanOnce(ByRef str, ByRef idx)
                Dim c, ms
                
                ' пропустить пробелы
                idx = SkipWhitespace(str, idx)
                c = Mid(str, idx, 1)
        
                ' дальше идет объект, считать его
                If c = "{" Then
                    idx = idx + 1
                    Set ScanOnce = ParseObject(str, idx)
                    Exit Function
                ' дальше идет массив
                ElseIf c = "[" Then
                    idx = idx + 1
                    ScanOnce = ParseArray(str, idx)
                    Exit Function
                ' дальше идет строка в кавычках (значение свойства)
                ElseIf c = """" Then
                    idx = idx + 1
                    ScanOnce = ParseString(str, idx)
                    Exit Function
                ' нулл (значение свойства)
                ElseIf c = "n" And StrComp("null", Mid(str, idx, 4)) = 0 Then
                    idx = idx + 4
                    ScanOnce = Null
                    Exit Function
                ' true
                ElseIf c = "t" And StrComp("true", Mid(str, idx, 4)) = 0 Then
                    idx = idx + 4
                    ScanOnce = True
                    Exit Function
                ' false
                ElseIf c = "f" And StrComp("false", Mid(str, idx, 5)) = 0 Then
                    idx = idx + 5
                    ScanOnce = False
                    Exit Function
                End If
        
                ' пришли сюда - вероятно, число
                Set ms = NumberRegex.Execute(Mid(str, idx))
                If ms.Count = 1 Then
                    idx = idx + ms(0).Length
                    dim TempVal
                    if IsObject(ms(0)) then
                      TempVal = ms(0).Value
                    else
                      TempVal = ms(0)
                    end if
                    TempVal = join(Split(TempVal, ".")  , Application.DecimalSeparatorSys)
                    ScanOnce = CDbl( TempVal)
                    Exit Function
                End If
        
                Exception.Raise "Exception", "No JSON object could be ScanOnced"
            End Function
        
            ' объект возвращается в виде ассоциативного массива. Ключи - имена свойств, а итемсы - значения
            ' Значения могут быть или простыми (число, строка, логическое, ...), или объектами, или массивами
            Private Function ParseObject(ByRef str, ByRef idx)
                Dim c, key, value
                Set ParseObject = CreateObject("Scripting.Dictionary")
        
                ' пропустить пробелы
                idx = SkipWhitespace(str, idx)
                c = Mid(str, idx, 1)
        
                ' пустой объект
                If c = "}" Then
                    idx = idx + 1
                    Exit Function
                ' имя свойства должно быть в кавычках
                ElseIf c <> """" Then
                    Exception.Raise "Exception", "Expecting property name"
                End If
        
                ' пришли сюда - разбираем имя свойства
                idx = idx + 1
        
                Do
                    ' имя свойства (заодно проглотит закрывающую кавычку)
                    key = ParseString(str, idx)
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx)
                    ' имя и значение разделяются двоеточием
                    If Mid(str, idx, 1) <> ":" Then
                        Exception.Raise "Exception", "Expecting : delimiter"
                    End If
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx + 1)
                    ' значение свойства может быть простым (число\строка\дата),
                    ' или тоже объектом, или массивом неизвестно чего
                    ' вызываем рекурсивно разбор следующего куска
                    If Mid(str, idx, 1) = "{" Then
                        Set value = ScanOnce(str, idx)
                    Else
                        value = ScanOnce(str, idx)
                    End If
                    
                    ' добавить свойство в список свойств
                    ParseObject.Add key, value
        
                    ' конец массива
                    If Mid(str, idx, 1) = "]" Then
                      idx = idx + 1
                    End If
        
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx)
                    c = Mid(str, idx, 1)
                    ' или конец объекта
                    If c = "}" Then
                        Exit Do
                    ' или должна быть запятая перед следующим свойством
                    ElseIf c <> "," Then
                        Exception.Raise "Exception", "Expecting , delimiter"
                    End If
        
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx + 1)
                    c = Mid(str, idx, 1)
                    ' начало следующего имени ????? было закомментировано
                    If c <> """" Then
                        Exception.Raise "Exception", "Expecting property name"
                    End If
        
                    idx = idx + 1
                Loop
        
                idx = idx + 1
            End Function
        
            ' разобрать массив (простых значений, или объектов)
            Private Function ParseArray(ByRef str, ByRef idx)
                Dim c, values, value
                Set values = CreateObject("Scripting.Dictionary")
                ' пропустить пробелы
                idx = SkipWhitespace(str, idx)
                c = Mid(str, idx, 1)
        
                ' пустой массив
                If c = "]" Then
                    idx = idx + 1
                    ParseArray = values.Items
                    Exit Function
                End If
        
                Do
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx)
                    
                    ' считать элемент массива, который может быть объектом,тогда Set, или чем-то другим
                    If Mid(str, idx, 1) = "{" Then
                        Set value = ScanOnce(str, idx)
                    Else
                        value = ScanOnce(str, idx)
                    End If
                    
                    ' добавить элемент массива в список
                    values.Add values.Count, value
        
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx)
                    c = Mid(str, idx, 1)
                    
                    ' или конец массива
                    If c = "]" Then
                        Exit Do
                    ' или запятая перед следующим элементом ????? было закомментировано
                    ElseIf c <> "," Then
                        Exception.Raise "Exception", "Expecting delimiter"
                      dim u
                    End If
        
                    idx = idx + 1
                Loop
        
                idx = idx + 1
                ParseArray = values.Items
            End Function
        
            ' считать строку (кириллица закодирована)
            Private Function ParseString(ByRef str, ByRef idx)
                Dim chunks, content, terminator, ms, esc, char
                Set chunks = CreateObject("Scripting.Dictionary")
        
                ' строка может содержать закодированные кириллические символы
                ' строка заканчивается кавычкой , поэтому цикл пока не нашли кавычку или ошибку
                Do
                    ' считали "слово"
                    Set ms = StringChunk.Execute(Mid(str, idx))
                    ' строка не соответствует шаблону
                    If ms.Count = 0 Then
                        Exception.Raise "Exception", "Unterminated string starting"
                    End If
        
                    content = ms(0).Submatches(0)
                    terminator = ms(0).Submatches(1)
                    If Len(content) > 0 Then
                        chunks.Add chunks.Count, content
                    End If
        
                    idx = idx + ms(0).Length
        
                    ' если закончилось кавычкой - текст разобран до конца, выходим
                    If terminator = """" Then
                        Exit Do
                    ' если не кавычка, то должен быть специальный символ, начинающийся с \ (закодированная кириллица)
                    ElseIf terminator <> "\" Then
                        Exception.Raise "Exception", "Invalid control character"
                    End If
        
                    esc = Mid(str, idx, 1)
        
                    ' что идет после \ ?
                    ' "u" означает 16-чный код (закодированная кириллица
                    If esc <> "u" Then
                        ' символы перевода каретки, ввода и тп
                        Select Case esc
                            Case """" char = """"
                            Case "\"  char = "\"
                            Case "/"  char = "/"
                            Case "b"  char = b
                            Case "f"  char = f
                            Case "n"  char = n
                            Case "r"  char = r
                            Case "t"  char = t
                            Case Else
                              Exception.Raise "Exception", "Invalid escape"
                        End Select
                        idx = idx + 1
                    Else ' "u" означает 16-чный код
                        char = ChrW("&H" & Mid(str, idx + 1, 4))
                        idx = idx + 5
                    End If
        
                    chunks.Add chunks.Count, char
                Loop
        
                ParseString = Join(chunks.Items, "")
            End Function
        
            ' пропустить пробелы
            Private Function SkipWhitespace(ByRef str, ByVal idx)
                Do While idx <= Len(str) And _
                    InStr(Whitespace, Mid(str, idx, 1)) > 0
                    idx = idx + 1
                Loop
                SkipWhitespace = idx
            End Function
        
        End Class
        
        
        
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 147026436_1220419898
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      NAME: "TVB_gs_Json"
      COMMENT: ~
      EVENT: ~
      FUNCTIONTYPE: ~
      GROUPNAME: ~
      INHERITEDRULE: 0
      LANGUAGE: "VBScript"
      LOCALNAME: ~
      MODIFYDATE: ~
      MODULE: "VBCLASSES"
      MODULECODE: "1010001_17 APPLICATION"
      OBJECTNAME: "APPLICATION"
      OWNERNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      USEDEBUGINFO: 0
      EDITIONDATE: 2019-09-03T17:37:35+03:00
      DISPLAYSCRIPT: | 
        JSONSTRING
        JSONCURRENCY
        
      ENTEREDPARAMS: ~
      SCRIPT: | 
        option explicit
        '###############################################################################
        'класс для разбора JSON - строки
        '###############################################################################
        Class TVB_gs_Json
            'Original:
            'Author: Demon
            'Date: 2012/5/3
            'Website: http://demon.tw
            
            'Edited by Alexandra
            Private Whitespace, NumberRegex, StringChunk
            Private b, f, r, n, t
        
            Private Sub Class_Initialize
                Whitespace = " " & vbTab & vbCr & vbLf
                ' символы окончания строки
                b = ChrW(8)
                f = vbFormFeed
                r = vbCr
                n = vbLf
                t = vbTab
        
                Set NumberRegex = New RegExp
                ' шаблон числа
                NumberRegex.Pattern = "(-?(?:0|[1-9]\d*))(\.\d+)?([eE][-+]?\d+)?"
                NumberRegex.Global = False
                NumberRegex.MultiLine = True
                NumberRegex.IgnoreCase = True
                ' шаблон строки (слова). Может начинаться с пробелов, заканчивается кавычкой (конец всей строки),
                ' или 16-ным кодом (ведь кириллица будет закодирована)
                ' первые круглые скобки - сама строка, вторые - разделитель, которым она заканчивается
                Set StringChunk = New RegExp
                StringChunk.Pattern = "([\s\S]*?)([""\\\x00-\x1f])"
                StringChunk.Global = False
                StringChunk.MultiLine = True
                StringChunk.IgnoreCase = True
            End Sub
        
            'Return a JSON string representation of a VBScript data structure
            'Supports the following objects and types
            '+-------------------+---------------+
            '| VBScript          | JSON          |
            '+===================+===============+
            '| Dictionary        | object        |
            '+-------------------+---------------+
            '| Array             | array         |
            '+-------------------+---------------+
            '| String            | string        |
            '+-------------------+---------------+
            '| Number            | number        |
            '+-------------------+---------------+
            '| True              | true          |
            '+-------------------+---------------+
            '| False             | false         |
            '+-------------------+---------------+
            '| Null              | null          |
            '+-------------------+---------------+
            Public Function Encode(ByRef obj)
                Dim buf, i, c, g
                Set buf = CreateObject("Scripting.Dictionary")
                Select Case VarType(obj)
                    Case vbNull
                        buf.Add buf.Count, "null"
                    Case vbBoolean
                        If obj Then
                            buf.Add buf.Count, "true"
                        Else
                            buf.Add buf.Count, "false"
                        End If
                    Case vbInteger, vbLong, vbSingle, vbDouble
                        buf.Add buf.Count, obj
                    Case vbString
                        buf.Add buf.Count, """"
                        For i = 1 To Len(obj)
                            c = Mid(obj, i, 1)
                            Select Case c
                                Case """" buf.Add buf.Count, "\"""
                                Case "\"  buf.Add buf.Count, "\\"
                                Case "/"  buf.Add buf.Count, "/"
                                Case b    buf.Add buf.Count, "\b"
                                Case f    buf.Add buf.Count, "\f"
                                Case r    buf.Add buf.Count, "\r"
                                Case n    buf.Add buf.Count, "\n"
                                Case t    buf.Add buf.Count, "\t"
                                Case Else
                                    If AscW(c) >= 0 And AscW(c) <= 31 Then
                                        c = Right("0" & Hex(AscW(c)), 2)
                                        buf.Add buf.Count, "\u00" & c
                                    Else
                                        buf.Add buf.Count, c
                                    End If
                            End Select
                        Next
                        buf.Add buf.Count, """"
                    Case vbArray + vbVariant
                        g = True
                        buf.Add buf.Count, "["
                        For Each i In obj
                            If g Then g = False Else buf.Add buf.Count, ","
                            buf.Add buf.Count, Encode(i)
                        Next
                        buf.Add buf.Count, "]"
                    Case vbObject
                        If TypeName(obj) = "Dictionary" Then
                            g = True
                            buf.Add buf.Count, "{"
                            For Each i In obj
                                If g Then g = False Else buf.Add buf.Count, ","
                                buf.Add buf.Count, """" & i & """" & ":" & Encode(obj(i))
                            Next
                            buf.Add buf.Count, "}"
                        Else
        '                    Err.Raise 8732,,"None dictionary object"
                            Exception.Raise "Exception", "None dictionary object"
                        End If
                    Case Else
                        buf.Add buf.Count, """" & CStr(obj) & """"
                End Select
                Encode = Join(buf.Items, "")
            End Function
        
            'Return the VBScript representation of ``str(``
            'Performs the following translations in decoding
            '+---------------+-------------------+
            '| JSON          | VBScript          |
            '+===============+===================+
            '| object        | Dictionary        |
            '+---------------+-------------------+
            '| array         | Array             |
            '+---------------+-------------------+
            '| string        | String            |
            '+---------------+-------------------+
            '| number        | Double            |
            '+---------------+-------------------+
            '| true          | True              |
            '+---------------+-------------------+
            '| false         | False             |
            '+---------------+-------------------+
            '| null          | Null              |
            '+---------------+-------------------+
            ' разобрать json
            ' результат возвращается двух видах:
            ' 1) сама ф-я возвращает дерево из Scripting.Dictinary
            ' 2) попутно заполняется объект JSonTree
            Public Function Decode(ByRef str)
             ' объект для хранения разобранного json
              dim JSonTree
              set JSonTree = new JSonObject
        
              Dim idx
              idx = SkipWhitespace(str, 1)
              ' еси массив, то привязываем его к корневому объекту
              if IsArray(str) then
                dim ObjProperty
                set ObjProperty = JSonTree.AddProperty
                ObjProperty.Name = "gsRootItem"
                Call ScanOnce(str, 1, ObjProperty)
              else
                idx = idx + 1
                Call ParseObject(str, idx, JSonTree)
              end if
              set Decode = JSonTree
            End Function
            
            ' определить, что текст является массивом
            Public Function IsArray(ByVal Str)
                Dim idx
                idx = SkipWhitespace(str, 1)
                IsArray = (Mid(str, idx, 1) = "[" )
            End Function
        
        
            ' рекурсия для разбора
            ' параметы: строка, позиция в строке, родительский объект (или массив)
            ' параллельно с возвратом результата ф-я считывает данные в новый объект и привязывает его к ParentObj
            ' Если ParentObj - массив (JSONArray) , то нужно создать новый элемент (простое значение, объект, массив и добавить в массив)
            ' Если ParentObj - свойство (JSONProperty), то нужно создать новое значение и привязать к св-ву
            Private Sub ScanOnce(ByRef str, ByRef idx, ByRef ParentObj)
                Dim c, ms
        
                ' пропустить пробелы
                idx = SkipWhitespace(str, idx)
                c = Mid(str, idx, 1)
        
                ' объект, в который считаются результаты
                ' из них строится "дерево результатов"
                ' 1) Определяем тип данных, которые идут дальше. В зависимости от типа создаем ValueObj
                '  ( JSonObject, JSonArray, JSonValue)
                ' 2) запускаем ф-ю, которая обработает именно этот тип
                ' 3) присоединяем к ParentObj с помощью метода AddValue (есть и у JSONProperty, и у JSONArray
                dim ValueObj
        
        
                ' дальше идет объект, считать его
                If c = "{" Then
                    idx = idx + 1
                    set ValueObj = new JSonObject
                    call ParseObject(str, idx, ValueObj)
                    call ParentObj.AddValue(ValueObj)
                    Exit Sub
                ' дальше идет массив
                ElseIf c = "[" Then
                    idx = idx + 1
                    set ValueObj = new JSonArray
                    call ParseArray(str, idx, ValueObj)
                    call ParentObj.AddValue(ValueObj)
                    Exit Sub
                ' дальше идет строка в кавычках (значение свойства)
                ElseIf c = """" Then
                    idx = idx + 1
                    set ValueObj = new JSonValue
                    ValueObj.Value = ParseString(str, idx)
                    call ParentObj.AddValue(ValueObj)
                    Exit Sub
                ' нулл (значение свойства)
                ElseIf c = "n" And StrComp("null", Mid(str, idx, 4)) = 0 Then
                    idx = idx + 4
                    set ValueObj = new JSonValue
                    ValueObj.Value = Null
                    call ParentObj.AddValue(ValueObj)
                    Exit Sub
                ' true
                ElseIf c = "t" And StrComp("true", Mid(str, idx, 4)) = 0 Then
                    idx = idx + 4
                    set ValueObj = new JSonValue
                    ValueObj.Value = True
                    call ParentObj.AddValue(ValueObj)
                    Exit Sub
                ' false
                ElseIf c = "f" And StrComp("false", Mid(str, idx, 5)) = 0 Then
                    idx = idx + 5
                    set ValueObj = new JSonValue
                    ValueObj.Value = False
                    call ParentObj.AddValue(ValueObj)
                    Exit Sub
                End If
        
                ' пришли сюда - вероятно, число
                Set ms = NumberRegex.Execute(Mid(str, idx))
                If ms.Count = 1 Then
                    idx = idx + ms(0).Length
                    dim TempVal
                    if IsObject(ms(0)) then
                      TempVal = ms(0).Value
                    else
                      TempVal = ms(0)
                    end if
                    TempVal = join(Split(TempVal, ".")  , Application.DecimalSeparatorSys)
        
                    set ValueObj = new JSonValue
                    ValueObj.Value = CDbl( TempVal)
                    call ParentObj.AddValue(ValueObj)
        
                    Exit Sub
                End If
        
                Exception.Raise "Exception", "No JSON object could be ScanOnced"
            End Sub
        
            ' считать объект, записать его в Obj
            ' Значения могут быть или простыми (число, строка, логическое, ...), или объектами, или массивами
            ' параметы: строка, позиция в строке, объект JSonObject, в который запишется результат
            Private Sub ParseObject(ByRef str, ByRef idx, ByRef Obj)
                Dim c, PropertyName, PropertyItem
        
                ' пропустить пробелы
                idx = SkipWhitespace(str, idx)
                c = Mid(str, idx, 1)
        
                ' пустой объект
                If c = "}" Then
                    idx = idx + 1
                    Exit Sub
                ' имя свойства должно быть в кавычках
                ElseIf c <> """" Then
                    Exception.Raise "Exception", "Expecting property name"
                End If
        
        
                ' пришли сюда - разбираем имя свойства
                idx = idx + 1
        
                ' цикл по свойствам обекта
                Do
                    ' имя свойства (заодно проглотит закрывающую кавычку)
                    PropertyName = ParseString(str, idx)
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx)
                    ' имя и значение разделяются двоеточием
                    If Mid(str, idx, 1) <> ":" Then
                        Exception.Raise "Exception", "Expecting : delimiter"
                    End If
        
                    ' добавляем новое свойство
                    set PropertyItem = Obj.AddProperty
                    PropertyItem.Name = Trim(PropertyName)
        
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx + 1)
                    ' значение свойства может быть простым (число\строка\дата),
                    ' или тоже объектом, или массивом неизвестно чего
                    ' вызываем рекурсивно разбор следующего куска
                    call ScanOnce(str, idx, PropertyItem)
        
        
                    ' конец массива
                    If Mid(str, idx, 1) = "]" Then
                      idx = idx + 1
                    End If
        
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx)
                    c = Mid(str, idx, 1)
                    ' или конец объекта
                    If c = "}" Then
                        Exit Do
                    ' или должна быть запятая перед следующим свойством
                    ElseIf c <> "," Then
                        Exception.Raise "Exception", "Expecting , delimiter"
                    End If
        
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx + 1)
                    c = Mid(str, idx, 1)
                    ' начало следующего имени
                    If c <> """" Then
                        Exception.Raise "Exception", "Expecting property name"
                    End If
        
                    idx = idx + 1
                Loop
        
                idx = idx + 1
            End Sub
        
            ' разобрать массив (простых значений, или объектов)
            ' параметы: строка, позиция в строке, массив, в который добавляется результат
            Private Sub ParseArray(ByRef str, ByRef idx, ByRef ArrObj)
                Dim c
                ' пропустить пробелы
                idx = SkipWhitespace(str, idx)
                c = Mid(str, idx, 1)
        
                ' пустой массив
                If c = "]" Then
                    idx = idx + 1
                    Exit Sub
                End If
        
                Do
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx)
        
                    ' считать элемент массива, который может быть объектом, массивом, простым значением
                    call ScanOnce(str, idx, ArrObj)
        
                    ' пропустить пробелы
                    idx = SkipWhitespace(str, idx)
                    c = Mid(str, idx, 1)
        
                    ' или конец массива
                    If c = "]" Then
                        Exit Do
                    ' или запятая перед следующим элементом ????? было закомментировано
                    ElseIf c <> "," Then
                        Exception.Raise "Exception", "Expecting delimiter"
                    End If
        
                    idx = idx + 1
                Loop
        
                idx = idx + 1
            End Sub
        
            ' считать строку (кириллица закодирована)
            ' параметы: строка, позиция в строке
            Private Function ParseString(ByRef str, ByRef idx)
                Dim content, terminator, ms, esc, char
                ParseString = ""
        
                ' строка может содержать закодированные кириллические символы
                ' строка заканчивается кавычкой , поэтому цикл пока не нашли кавычку или ошибку
                Do
                    ' считали "слово"
                    Set ms = StringChunk.Execute(Mid(str, idx))
                    ' строка не соответствует шаблону
                    If ms.Count = 0 Then
                        Exception.Raise "Exception", "Unterminated string starting"
                    End If
        
                    content = ms(0).Submatches(0)
                    terminator = ms(0).Submatches(1)
        
                    ParseString = ParseString & content
                    idx = idx + ms(0).Length
        
                    ' если закончилось кавычкой - текст разобран до конца, выходим
                    If terminator = """" Then
                        Exit Do
                    ' если не кавычка, то должен быть специальный символ, начинающийся с \ (закодированная кириллица)
                    ElseIf terminator <> "\" Then
                        Exception.Raise "Exception", "Invalid control character"
                    End If
        
                    esc = Mid(str, idx, 1)
        
                    ' что идет после \ ?
                    ' "u" означает 16-чный код (закодированная кириллица
                    If esc <> "u" Then
                        ' символы перевода каретки, ввода и тп
                        Select Case esc
                            Case """" char = """"
                            Case "\"  char = "\"
                            Case "/"  char = "/"
                            Case "b"  char = b
                            Case "f"  char = f
                            Case "n"  char = n
                            Case "r"  char = r
                            Case "t"  char = t
                            Case Else
                              Exception.Raise "Exception", "Invalid escape"
                        End Select
                        idx = idx + 1
                    Else ' "u" означает 16-чный код
                        char = ChrW("&H" & Mid(str, idx + 1, 4))
                        idx = idx + 5
                    End If
        
                   ParseString = ParseString & char
                Loop
        
            End Function
        
            ' пропустить пробелы
            Private Function SkipWhitespace(ByRef str, ByVal idx)
                Do While idx <= Len(str) And _
                    InStr(Whitespace, Mid(str, idx, 1)) > 0
                    idx = idx + 1
                Loop
                SkipWhitespace = idx
            End Function
        
        End Class
        
        '###############################################################################
        'классы для хранения разобранного JSON
        '###############################################################################
        '-------------------------------------------------------------------------------
        ' 1) простое значение (строка, число, логическое)
        ' Свойства:
        '   ClassName: string - имя класса(всегда = "JSonValue" )
        '   Value: variant (string, boolean, numeric, null) - значение (число, строка, логическое, нулл)
        '   Json: string - представление в формате Json
        '--------------------
        Class JSonValue
        
          Public Value
          
          '-----------------------------
          Public Property Get ClassName
            ClassName = "JSonValue"
          End Property
          
          '-----------------------------
          ' в формате Json
          Public Property Get Json
            Select Case VarType(Value)
              Case vbNull
                Json = "null"
              Case vbBoolean
                If Value Then
                  Json = "true"
                Else
                  Json = "false"
                End If
              Case vbInteger, vbLong, vbSingle
                Json = Value
              Case vbDouble, vbCurrency
                Json = JSonCurrency(Value)
              ' строка кодируется как ссылка в браузере (кириллица подменяется на 16ные коды)
              Case vbString
                Json = JSonString (Value)
              Case Else
                Json = "null"
            End Select
          End Property
          
        End Class
        
        '-------------------------------------------------------------------------------
        
        ' 2) массив (в нем могут быть простые значения, другие массивы, объекты)
        ' Свойства:
        '   ClassName: string - имя класса(всегда = "JSonArray" )
        '   Json: string - представление в формате Json
        ' Методы:
        '   Sub AddObjectItem(ByRef L) - добавить в массив объект L
        '         (L может быть JSonObject, JSonValue или JSonArray)
        '   Sub AddValue(ByRef V) - то же, что и AddObjectItem
        '   Function ObjectItem(ByVal i): object (JSonObject, JSonValue или JSonArray) -
        '         вернуть элемент массива по индексу
        '   Sub ClearObjectItems - очистить массив
        '   Function ObjectItemsCount: integer - кол-во элементов в массиве
        '   Function RecursiveValue (PropertyName) : object (JSonObject, JSonValue или JSonArray) -
        '         найти первое попавшееся св-во с именем PropertyName и вернуть его значение
        '   Function AddValue_Simple: JSonValue - добавить новый элемент типа JSonValue и вернуть его
        '   Function AddValue_Array: JSonArray - добавить новый элемент типа JSonArray и вернуть его
        '   Function AddValue_Object: JSonObject - добавить новый элемент типа JSonObject и вернуть его
        
        Class JSonArray
        
          '----------------------------
          Public Property Get ClassName
            ClassName = "JSonArray"
          End Property
          
          '-----------------------------
          ' в формате Json
          Public Property Get Json
            dim Res, i, O
            Res = ""
        
            for i = 0 to UBound(FObjectItems)
              set O = FObjectItems(i)
              if Assigned(O) then
                if Res <> "" then Res = Res & ", " & VBCR
                Res = Res & O.Json
              end if
            next
            Json = "[" & VBCR & Res & "]" & VBCR
          End Property
          
          '----------------------------
          ' значения (массив объектов)
          ' Значения. Массив из JSonObject  or  JSonValue or JSonArray
          Private FObjectItems
        
          '----------------------------
          ' Добавить значение
          Public Sub AddObjectItem(ByRef L)
            dim C
            C = UBound(FObjectItems) + 1
            redim preserve FObjectItems(C)
            set FObjectItems(C) = L
          End Sub
          
          '----------------------------
          ' Считать значение по номеру
          Public Function ObjectItem(ByVal i)
            set ObjectItem = nothing
            if UBound(FObjectItems) >= i then
              set ObjectItem = FObjectItems(i)
            end if
          End Function
          
          '----------------------------
          ' Удалить все значения
          Public Sub ClearObjectItems
            dim i
            for i = 0 to UBound(FObjectItems)
              set FObjectItems(i) = nothing
            next
            redim preserve FObjectItems(-1)
          End Sub
          
          '----------------------------
          ' Кол-во значений
          Public Function ObjectItemsCount
            ObjectItemsCount = UBound(FObjectItems) + 1
          End Function
        
          '----------------------------
          ' добавить значение
          Public Sub AddValue(ByRef V)
            call AddObjectItem(V)
          End Sub
          
          '----------------------------
          ' добавить значение (простое JSonValue)
          Public Function AddValue_Simple
            dim V
            set V = new JSonValue
            call AddObjectItem(V)
            set AddValue_Simple = V
          End Function
          
          '----------------------------
          ' добавить значение (массив JSonArray)
          Public Function AddValue_Array
            dim V
            set V = new JSonArray
            call AddObjectItem(V)
            set AddValue_Array = V
          End Function
          
          '----------------------------
          ' добавить значение (объект JSonObject)
          Public Function AddValue_Object
            dim V
            set V = new JSonObject
            call AddObjectItem(V)
            set AddValue_Object = V
          End Function
          
          '----------------------------
          ' значение по имени свойства объекта, находящегося в массивк (рекурсивно)
          ' если свойство - объект или массив, то искать у вложенных объектов тоже
          Public Function RecursiveValue (PropertyName)
            dim Result
            set Result = nothing
            dim i, P
            for i = 0 to UBound(FObjectItems)
              set P = FObjectItems(i)
              if(P.ClassName = "JSonObject") or ( P.ClassName = "JSonArray") then
                set Result = P.RecursiveValue (PropertyName)
                if Assigned(Result) then
                  exit for
                end if
              end if
            next
            set RecursiveValue = Result
          End Function
          
          '----------------------------
          Private Sub Class_Initialize
            FObjectItems = Array()
          End Sub
        
          '----------------------------
          Private Sub Class_Terminate
            call ClearObjectItems
          End Sub
        
        End Class
        
        '-------------------------------------------------------------------------------
        
        ' 3) свойство
        ' Свойства:
        '   ClassName: string - имя класса(всегда = "JSONProperty" )
        '   Json: string - представление в формате Json
        '   Name: string - имя свойства
        '   Value: object  (JSonObject, JSonValue или JSonArray) - значение
        ' Методы:
        '   Sub AddValue(ByRef V) - присвоить Value значение V
        Class JSONProperty
          '----------------------------
          Public Property Get ClassName
            ClassName = "JSONProperty"
          End Property
          
          '-----------------------------
          ' в формате Json
          Public Property Get Json
            if Assigned(Value) then
              Json = JSonString(Name) & ":" & Value.Json
            else
              Json = JSonString(Name) & ":null "
            end if
          End Property
        
          '----------------------------
          ' имя
          Public Name
          
          '----------------------------
          ' значение   (простое значение, объект, массив)
          Public Value
        
          '----------------------------
          ' присвоить значение
          Public Sub AddValue(ByRef V)
            if Assigned(Value) then
              set Value = nothing
            end if
            set Value = V
          End Sub
        
          '----------------------------
          Private Sub Class_Terminate
            set Value = nothing
          End Sub
        
        End Class
        
        '-------------------------------------------------------------------------------
        
        ' 4) объект
        ' Свойства:
        '   ClassName: string - имя класса(всегда = "JSonObject" )
        '   Json: string - представление в формате Json
        ' Методы:
        '   Function AddProperty: JSONProperty  - добавіть новое св-во і вернуть его
        '   Function PropertyItem(ByVal i): JSONProperty - вернуть св-во по индексу
        '   Sub Add(ByRef P) - добавіть св-во P
        '   Sub ClearProperties - Удалить все свойства
        '   Function PropertiesCount: integer - кол-во св-в
        '   Function SimpleValue (PropertyName, DefaultValue)  variant (string, numeric, boolean, null) -
        '         значение по имени свойства PropertyName (простое). Если получить невозможно, подставить DefaultValue
        '   Function Value (PropertyName): object (JSonObject, JSonValue или JSonArray) -
        '         значение по имени свойства PropertyName (объект).
        '   Function RecursiveValue (PropertyName) : object (JSonObject, JSonValue или JSonArray) -
        '         найти первое попавшееся св-во с именем PropertyName и вернуть его значение
        '   Sub AddProperty_Simple(Name, Value) - добавить св-во, имя Name, создать значение,
        '         создать JSonValue, присвоить  Value
        '   Sub AddProperty_Object(Name, Value) - добавить св-во, имя Name, присвоить ему объект Value
        Class JSonObject
          '----------------------------
          Public Property Get ClassName
            ClassName = "JSonObject"
          End Property
          
          '-----------------------------
          ' в формате Json
          Public Property Get Json
            dim Res, i, O
            Res = ""
        
            for i = 0 to UBound(FProperties)
              set O = FProperties(i)
              if Assigned(O) then
                if Res <> "" then Res = Res & ", " & VBCR
                Res = Res & O.Json
              end if
            next
            Json = "{" & Res & "}" & VBCR
          End Property
          
          '----------------------------
          ' Свойства. Массив из JSONProperty
          Private FProperties
          
          '----------------------------
          ' Добавить свойство
          Public Sub Add(ByRef P)
            dim C
            C = UBound(FProperties) + 1
            redim preserve FProperties(C)
            set FProperties(C) = P
          End Sub
          
          '----------------------------
          ' Добавить свойство
          Public Function AddProperty
            dim C, L
            C = UBound(FProperties) + 1
            set L = new JSONProperty
            redim preserve FProperties(C)
            set FProperties(C) = L
            set AddProperty = L
          End Function
          
          '----------------------------
          ' Считать свойство по номеру
          Public Function PropertyItem(ByVal i)
            set PropertyItem = nothing
            if UBound(FProperties) >= i then
              set PropertyItem = FProperties(i)
            end if
          End Function
          
          '----------------------------
          ' Удалить все свойства
          Public Sub ClearProperties
            dim i
            for i = 0 to UBound(FProperties)
              set FProperties(i) = nothing
            next
            redim preserve FProperties(-1)
          End Sub
          
          '----------------------------
          ' Кол-во свойств
          Public Function PropertiesCount ': integer
            PropertiesCount = UBound(FProperties) + 1
          End Function
          
          '----------------------------
          ' значение по имени свойства
          Public Function Value (PropertyName) ': object( JsonValue, JSonArray, JSonObject)
            set Value = nothing
            dim i, P
            for i = 0 to UBound(FProperties)
              set P = FProperties(i)
              if P.Name = PropertyName then
                set Value = P.Value
                exit for
              end if
            next
          End Function
          
          '----------------------------
          ' значение по имени свойства (не объект, а число, строка и тд)
          ' DefaultValue - значение по умолчанию, если св-ва нет
          Public Function SimpleValue (PropertyName, DefaultValue) ': variant
            SimpleValue = DefaultValue
            dim i, P, oV
            for i = 0 to UBound(FProperties)
              set P = FProperties(i)
              if P.Name = PropertyName then
                set oV = P.Value
                if Assigned(oV) then
                  if oV.ClassName = "JSonValue" then
                    SimpleValue = oV.Value
                  end if
                end if
                exit for
              end if
            next
          End Function
          
          '----------------------------
          ' значение по имени свойства (рекурсивно)
          ' если свойство - объект или массив, то искать у вложенных объектов тоже
          Public Function RecursiveValue (PropertyName)
            dim Result, Res
            set Result = nothing
            dim i, P
            for i = 0 to UBound(FProperties)
              set P = FProperties(i)
              if P.Name = PropertyName then
                set Result = P.Value
                exit for
              elseif (P.Value.ClassName = "JSonObject") or ( P.Value.ClassName = "JSonArray") then
                set Result = P.Value.RecursiveValue (PropertyName)
                if Assigned(Result) then exit for
              end if
            next
            set RecursiveValue = Result
          End Function
          
          '----------------------------
          ' добавить простое св-во с именем и значением
          Public Sub AddProperty_Simple(Name, Value)
            dim oV
            set oV = new JSonValue
            oV.Value = Value
            
            dim oP
            set oP = AddProperty
            oP.Name = Name
            set oP.Value = oV
          End Sub
          
          '----------------------------
          ' добавить св-во - объект с именем и значением
          Public Sub AddProperty_Object(Name, Value)
            dim oP
            set oP = AddProperty
            oP.Name = Name
            set oP.Value = Value
          End Sub
        
        
          '----------------------------
          Private Sub Class_Initialize
            FProperties = Array()
          End Sub
        
          '----------------------------
          Private Sub Class_Terminate
            call ClearProperties
          End Sub
        End Class
        
        '-------------------------------------------------------------------------------
        ' 5) функции конвертации данных в Json
        ' string to json
        Function JSonString(Value)
          dim i, c, Res
          Res = """"
          
          dim b, f, r, n, t
          b = ChrW(8)
          f = vbFormFeed
          r = vbCr
          n = vbLf
          t = vbTab
          For i = 1 To Len(Value)
            c = Mid(Value, i, 1)
            Select Case c
              Case """" Res = Res & "\"""
              Case "\"  Res = Res & "\\"
              Case "/"  Res = Res & "/"
              Case b    Res = Res & "\b"
              Case f    Res = Res & "\f"
              Case r    Res = Res & "\r"
              Case n    Res = Res & "\n"
              Case t    Res = Res & "\t"
              Case Else
                If AscW(c) >= 0 And AscW(c) <= 31 Then
                  c = Right("0" & Hex(AscW(c)), 2)
                  Res = Res & "\u00" & c
                Else
                  Res = Res & c
                End If
            End Select
          Next
          JSonString = Res & """"
        End Function
        
        '----------------------------
        ' currency, double to json
        Function JSonCurrency(Value)
          dim S
          S = CStr(Value)
        
          ' заменили "," на "."
          S = Join(Split(S, "," ), ".")
          JSonCurrency = S
        
        End Function
        